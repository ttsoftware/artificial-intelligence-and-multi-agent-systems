\documentclass[12pt]{article}
\usepackage[a4paper, hmargin={2.5cm, 2.5cm}, vmargin={2.5cm, 2.5cm}]{geometry}

\usepackage[nottoc,numbib]{tocbibind}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes, shadows, arrows, automata}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{float}
\usepackage[english]{varioref}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{etoolbox}
\usepackage{seqsplit}

\usepackage{fancyhdr}

\setlength\parindent{0pt}
\usepackage[parfill]{parskip}

\definecolor{mygray}{rgb}{0.9451,0.9451,0.9451}
\lstset{
  backgroundcolor=\color{mygray},
  basicstyle=\footnotesize\ttfamily,
  mathescape,
  breaklines=true,
  numbers=left,
  numberstyle=\ttfamily,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
  literate={->}{$\rightarrow$}{2}
           {Îµ}{$\varepsilon$}{1}
}

\linespread{1.3}

\title{
  \vspace{4cm}
  \begin{flushleft}
  \Large{\textbf{Warmup Assignment}} \\
  \large{Artificial Intelligence and Multi Agent Systems}
  \end{flushleft}
  \vspace{0cm}
  \begin{flushleft}
  \small
  \textit{\today}
  \end{flushleft}
  \vspace{12cm}
  \begin{flushleft}
  \small
  Troels Thomsen \texttt{152165} \\
  Rasmus Haarslev \texttt{152175} \\
  \end{flushleft}
}

\date{
	%
}

\begin{document}

\clearpage
\pagenumbering{gobble}
\thispagestyle{empty}
\maketitle

\newpage

\section{Exercise 1 (Seach Strategies)}

The results for these exercises can be seen in figure~\ref{benchmark-results}.


\subsection{a}
\label{sub:a}

The shortest length is 19, which we know because BFS will always find the shortest path if implemented correctly. BFS looks at all possible solutions and chooses the best solution.


\subsection{b}
\label{sub:b}

Running SAD2.lvl using the BFS strategy, we run out of memory before it finds any solutions.
This level is much more complex, since adding extra boxes increases the number of states exponentially, as each box and agent can be on each field in the level.


\subsection{c}
\label{sub:c}

The implementation can be seen in the \texttt{StrategyDFS.java} file, and the benchmarks can be seen in figure~\ref{benchmark-results}


\subsection{d}
\label{sub:d}

We designed a custom level for DFS with the following layout.

\begin{verbatim}
+++++++
+aAAAa+
+A 0 A+
+a A a+
+A A A+
+++++++
\end{verbatim}

This particular layout contains a lot of boxes to be moved around, with several goal states to be achieved simultaneously. This creates a very large solution space for BFS to explore in order to find the best solution. DFS on the other hand, can find a solution to this problem much more quickly, since almost any path will lead to a solution.


\subsection{e}
\label{sub:e}

We designed a custom level for BFS with the following layout.

\begin{verbatim}
+++++++++++++++++++++++++++++++++++++++++
+aA                                     +
+aA0B                                   +
+                                       +
+++++++++++++++++++++++++++++++++++++++++
\end{verbatim}

This particular layout is designed, so that the agent must look all directions in order to find the right direction to solve the level quickly. An ideal solution would make it so that the agent should go in all direction to solve it quickly. DFS is very slow for this level, since the space it can move the boxes around in is very large, so exploring a single path leads to a very slow solution.


\begin{figure}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Level & Client & Time & Memory Used & Solution Length & Nodes Explored \\
        \hline
        SAD1 & BFS & 0.13 sec & 9.30MB & 19 & 78 \\
        \hline
        SAD1 & DFS & 0.10 sec & 6.20MB & 27 & 44 \\
        \hline
        SAD2 & BFS & - & - & - & - \\
        \hline
        SAD2 & DFS & 7.81 sec & 570.94MB & 5781 & 6799 \\
        \hline
        friendOfDFS & BFS & - & - & - & - \\
        \hline
        friendOfDFS & DFS & 0.20 sec & 6.82MB & 94 & 94 \\
        \hline
        friendOfBFS & BFS & 0.20 sec & 5.58MB & 2 & 17 \\
        \hline
        friendOfBFS & DFS & - & - & - & - \\
        \hline
    \end{tabular}
    \caption{Benchmark without optimisations}
    \label{benchmark-results}
\end{figure}


\section{Exercise 2 (Optimisations)}
\label{sec:Exercise 2 (Optimisations)}

\subsection{a}
\label{sub:a}

\begin{figure}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Level & Client & Time & Memory Used & Solution Length & Nodes Explored \\
        \hline
        SAD1 & BFS & 0.08 sec & 2.48MB & 19 & 78 \\
        \hline
        SAD1 & DFS & 0.07 sec & 2.48MB & 27 & 44 \\
        \hline
        SAD2 & BFS & - & - & - & - \\
        \hline
        SAD2 & DFS & 5.33 sec & 18.64MB & 5781 & 6799 \\
        \hline
        friendOfDFS & BFS & - & - & - & - \\
        \hline
        friendOfDFS & DFS & 0.14 sec & 2.48MB & 94 & 94 \\
        \hline
        friendOfBFS & BFS & 0.08 sec & 2.48MB & 2 & 17 \\
        \hline
        friendOfBFS & DFS & 26.81 sec & 53.24MB & 20435 & 33912 \\
        \hline
    \end{tabular}
    \caption{Benchmark with optimisations for exercise 2a}
    \label{benchmark-results}
\end{figure}


\subsection{b}
\label{sub:b}

Using a hashmap to keep track of all the boxes will yeild a constant lookup time, and will use much less memory in almost any level that contains less boxes than total fields. Hashmaps has a bit of overhead, but in most cases, this will still be a net loss of memory usage.

With these changes, we would be able to find the goalState in constant time, as it wouldn't have to look through the entire board, but instead would just be able to look at where the boxes are directly.

getExpandedNodes would run slower with our changes, as it would no longer be able to lookup a specific field on the board in constant time. Instead, it would have to look through the locations of all boxes in order to make sure a given field is not occupied.



\end{document}
