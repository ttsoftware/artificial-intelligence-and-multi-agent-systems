\documentclass[12pt]{article}
\usepackage[a4paper, hmargin={2.5cm, 2.5cm}, vmargin={2.5cm, 2.5cm}]{geometry}

\usepackage[nottoc,numbib]{tocbibind}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes, shadows, arrows, automata}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{float}
\usepackage[english]{varioref}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{etoolbox}
\usepackage{seqsplit}

\usepackage{fancyhdr}

\setlength\parindent{0pt}
\usepackage[parfill]{parskip}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\definecolor{mygray}{rgb}{0.9451,0.9451,0.9451}

\lstset{
  language=Java,
  backgroundcolor=\color{mygray},
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  mathescape,
  breaklines=true,
  numbers=left,
  numberstyle=\ttfamily,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
  literate={->}{$\rightarrow$}{2}
           {Îµ}{$\varepsilon$}{1}
}

\linespread{1.3}

\title{
  \vspace{4cm}
  \begin{flushleft}
  \Large{\textbf{Warmup Assignment}} \\
  \large{Artificial Intelligence and Multi Agent Systems}
  \end{flushleft}
  \vspace{0cm}
  \begin{flushleft}
  \small
  \textit{\today}
  \end{flushleft}
  \vspace{12cm}
  \begin{flushleft}
  \small
  Troels Thomsen \texttt{152165} \\
  Rasmus Haarslev \texttt{152175} \\
  \end{flushleft}
}

\date{
	%
}

\begin{document}

\clearpage
\pagenumbering{gobble}
\thispagestyle{empty}
\maketitle

\newpage

\section{Exercise 1 (Seach Strategies)}

The results for these exercises can be seen in figure~\ref{benchmark-results}.


\subsection{a}
\label{sub:a}

BFS looks at all states in each branch before moving on to the next set of states. Thus, when BFS finds a solution, we are guaranteed that it will be the optimal solution, as any solution found later will be longer. The shortest length for this exercise is 19.

\subsection{b}
\label{sub:b}

Running SAD2.lvl using the BFS strategy, we run out of memory before it finds any solutions.
This level is much more complex, since adding extra boxes increases the number of states exponentially.


\subsection{c}
\label{sub:c}

The implementation can be seen in the \texttt{StrategyDFS.java} file, and the benchmarks can be seen in figure~\ref{benchmark-results}


\subsection{d}
\label{sub:d}

We designed a custom level for DFS with the following layout.

\begin{verbatim}
+++++++
+aAAAa+
+A 0 A+
+a A a+
+A A A+
+++++++
\end{verbatim}

This particular layout contains a lot of boxes to be moved around, with several goal states to be achieved simultaneously. This creates a very large solution space for BFS to explore in order to find the best solution. DFS on the other hand, can find a solution to this problem much more quickly, since almost any path will lead to a solution.


\subsection{e}
\label{sub:e}

We designed a custom level for BFS with the following layout.

\begin{verbatim}
+++++++++++++++++++++++++++++++++++++++++
+aA                                     +
+aA0B                                   +
+                                       +
+++++++++++++++++++++++++++++++++++++++++
\end{verbatim}

This particular layout is designed, so that the agent must look all directions in order to find the right direction to solve the level quickly. An ideal solution would make it so that the agent should go in all direction to solve it quickly. DFS is very slow for this level, since the space it can move the boxes around in is very large, so exploring a single path leads to a very slow solution.


\begin{figure}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Level & Client & Time & Memory Used & Solution Length & Nodes Explored \\
        \hline
        SAD1 & BFS & 0.13 sec & 9.30MB & 19 & 78 \\
        \hline
        SAD1 & DFS & 0.10 sec & 6.20MB & 27 & 44 \\
        \hline
        SAD2 & BFS & - & - & - & - \\
        \hline
        SAD2 & DFS & 7.81 sec & 570.94MB & 5781 & 6799 \\
        \hline
        friendOfDFS & BFS & - & - & - & - \\
        \hline
        friendOfDFS & DFS & 0.20 sec & 6.82MB & 94 & 94 \\
        \hline
        friendOfBFS & BFS & 0.20 sec & 5.58MB & 2 & 17 \\
        \hline
        friendOfBFS & DFS & - & - & - & - \\
        \hline
    \end{tabular}
    \caption{Benchmark without optimisations}
    \label{benchmark-results}
\end{figure}


\section{Exercise 2 (Optimisations)}
\label{sec:Exercise 2 (Optimisations)}

\subsection{a}
\label{sub:a}

\begin{figure}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Level & Client & Time & Memory Used & Solution Length & Nodes Explored \\
        \hline
        SAD1 & BFS & 0.08 sec & 2.48MB & 19 & 78 \\
        \hline
        SAD1 & DFS & 0.07 sec & 2.48MB & 27 & 44 \\
        \hline
        SAD2 & BFS & - & - & - & - \\
        \hline
        SAD2 & DFS & 5.33 sec & 18.64MB & 5781 & 6799 \\
        \hline
        friendOfDFS & BFS & - & - & - & - \\
        \hline
        friendOfDFS & DFS & 0.14 sec & 2.48MB & 94 & 94 \\
        \hline
        friendOfBFS & BFS & 0.08 sec & 2.48MB & 2 & 17 \\
        \hline
        friendOfBFS & DFS & 26.81 sec & 53.24MB & 20435 & 33912 \\
        \hline
    \end{tabular}
    \caption{Benchmark with optimisations for exercise 2a}
    \label{benchmark-results-2}
\end{figure}

\subsection{b}
\label{sub:b}

Using a hashmap to keep track of all the boxes will yeild a constant lookup time, and will use much less memory in almost any level that contains less boxes than total fields. Hashmaps has a bit of overhead, but in most cases, this will still be a net loss of memory usage.

With these changes, we would be able to find the goalState in constant time, as it wouldn't have to look through the entire board, but instead would just be able to look at where the boxes are directly.

getExpandedNodes would run slower with our changes, as it would no longer be able to lookup a specific field on the board in constant time. Instead, it would have to look through the locations of all boxes in order to make sure a given field is not occupied.


\section{Exercise 3 (Heuristics)}
\label{sec:Exercise 3 (Heuristics)}

\subsection{a}
\label{sub:a}

We're using a PriorityQueue data structure for the frontier in this exercise.

\begin{lstlisting}
public StrategyBestFirst(Heuristic h) {
    super();
    heuristic = h;
    frontier = new PriorityQueue<>(heuristic);
}

public Node getAndRemoveLeaf() { return frontier.poll(); }

public void addToFrontier(Node n) { frontier.offer(n); }
\end{lstlisting}

This simple implementation ensures that the PriorityQueue will be sorted according to the Heuristic compare function.

\subsection{b}
\label{sub:b}

The following listing shows our implementation of $h(n)$. We simply iterate over every box and calculate its distance to its closest goal, adding all the distances together and using this as the heuristic metric.

For the goal locations we implemented a static List<Pair<Integer, Integer>>, which contain the goal states. This list allows us to find the nearest goal to a given box in only $O(|goals|)$ time, instead of searching the entire board.

\begin{lstlisting}
/**
 * Returns how far each box is from their closest goals
 */
public int h(Node n) {
    // we wish to calculate the distance the boxes have from the goal
    char[][] boxes = n.getBoxes();
    int totalDistance = 0;

    for (int boxesRow = 0; boxesRow < boxes.length; boxesRow++) {
        for (int boxesCol = 0; boxesCol < boxes[boxesRow].length; boxesCol++) {
            if (n.boxAt(boxesRow, boxesCol)) {
                // we are in box boxesRow,boxesCol
                totalDistance += distanceFromGoal(boxesRow, boxesCol, boxes[boxesRow][boxesCol]);
            }
        }
    }

    return totalDistance;
}

/**
 * Returns the distance (row+col) the given coordinate is from a matching goal
 */
private int distanceFromGoal(int i, int j, char box) {
    char boxGoal = Character.toLowerCase(box);
    final int[] nearestGoal = {-1};

    Node.goalLocations.forEach((goalLocation) -> {
        // we are at the correct type of goal
        if (boxGoal == Node.goals[goalLocation.getKey()][goalLocation.getValue()]) {
            int distance = Math.abs(goalLocation.getKey() - i) + Math.abs(goalLocation.getValue() - j);
            if (distance < nearestGoal[0] || nearestGoal[0] == -1) {
                nearestGoal[0] = distance;
            }
        }
    });

    return nearestGoal[0];
}
\end{lstlisting}

\subsection{c}
\label{sub:c}

Our heuristic function calculates the distance each box has to its closest goal, and adds these distances together. This takes $O(n*m*|G|)$ time, where $n$, $m$ and $|G|$ are the length of either side of the board and the amount of goals on the board respectively.

Whenever a box is moved closer to its nearest goal, the total value of $h(n)$ decreases, thus giving us an approximation of how many steps are left to finish. $h(n)$ is guaranteed to go towards 0, if the board progresses toward the goal state and reach 0 in the goal state.

\subsection{d}
\label{sub:d}

As shown in Figure~\ref{benchmark-results-3} we notice that our three best-first-search algorithms do not necessarily find the same solutions.
Overall WA* performs best by having both the shortest average solution (25.8 excluding Crunch) and the fastest average time spent (0.34 excluding crunch).
This indicates that our heuristic is good. The solutions are better on average, when we weigh the heuristic function higher. In fact for the Crunch level we are only able to find a solution, if we increase the weight $W$. If we for instance chose $W=17$ we would find a solution of length 106, whereas at $W=5$ we cannot find any solution. The solution "quality" does not increase linearly with $W$ however. It seems we are able to find generally better solutions with slightly higher values of $W$, but of different lengths and with different number of nodes explored.

\begin{figure}[H]
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Level & Evaluation & Time & Memory Used & Solution Length & Nodes Explored \\
        \hline
        SAD1 & A* & 0.37 sec & 3.72MB & 19 & 77 \\
        \hline
        SAD1 & WA* & 0.29 sec & 3.72MB & 19 & 77 \\
        \hline
        SAD1 & Greedy & 0.32 sec & 3.72MB & 21 & 51 \\
        \hline
        SAD2 & A* & 1.32 sec & 24.18MB & 29 & 1293 \\
        \hline
        SAD2 & WA* & 0.28 sec & 4.34MB & 25 & 37 \\
        \hline
        SAD2 & Greedy & 0.35 sec & 4.34MB & 25 & 39 \\
        \hline
        friendofDFS & A* & 0.47 sec & 8.68MB & 10 & 388 \\
        \hline
        friendofDFS & WA* & 0.30 sec & 4.34MB & 12 & 15 \\
        \hline
        friendofDFS & Greedy & 0.41 sec & 4.34MB & 12 & 15 \\
        \hline
        friendofBFS & A* & 0.33 sec & 3.10MB & 2 & 2 \\
        \hline
        friendofBFS & WA* & 0.28 sec & 3.72MB & 2 & 2 \\
        \hline
        friendofBFS & Greedy & 0.29 sec & 3.72MB & 2 & 2 \\
        \hline
        Firefly & A* & 1.93 sec & 16.00MB & 60 & 7296 \\
        \hline
        Firefly & WA* & 0.55 sec & 5.58MB & 71 & 468 \\
        \hline
        Firefly & Greedy & 2.22 sec & 26.53MB & 310 & 13208 \\
        \hline
        Crunch & A* & - & - & - & - \\
        \hline
        Crunch & WA* (W=17) & 13.48 sec & 152.46MB & 106 & 56645 \\
        \hline
        Crunch & Greedy & 34.68 sec & 124.51MB & 174 & 130236 \\
        \hline
    \end{tabular}
    \caption{Benchmark with optimisations for exercise 3}
    \label{benchmark-results-3}
\end{figure}

\end{document}
